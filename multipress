#!/usr/bin/env bash
set -o errexit


print_stderr() {
	if [[ $1 == '0' ]]; then
		[[ $2 ]] && printf "$2" "${@:3}" 1>&2 || :
	else
		[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
		exit "$1"
	fi
}



name=
delim='__'
activation_timeout='0.3'
prevent_overrun=
dry_run=
cmd_segs=()
while [[ "$1" ]]; do
	case $1 in
		'--name'|'-n')
			shift; name=$1 ;;
		'--delim'|'-d')
			shift; delim=$1 ;;
		'--timeout'|'-t')
			shift; activation_timeout=$1 ;;
		'--prevent-overrun'|'-p')
			prevent_overrun=1 ;;
		'--dry-run')
			dry_run=1 ;;
		'--')
			shift; break ;;
		'-'*)
			print_stderr 1 '%s\n' 'unrecognized option: '"$1" ;;
		*)
			cmd_segs+=("$1")
	esac
	shift
done
cmd_segs+=("$@")



# Validate arguements
[[ $delim ]] || print_stderr 1 '%s\n' 'no command delimiter provided'
[[ ${#cmd_segs[@]} != '0' ]] || print_stderr 1 '%s\n' 'no command(s) provided'



# Define temp directory for fifo file
temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'



# Define function for generating fast checksums
bashash_main() {
	bashash__out=
	local \
		str=$1 \
		checksum_len=${2:-16} \
		checksum_arr=(1)
	local str_len=${#str}


	for (( i = 0; i < str_len; i++ )); do
		printf -v val '%d' "'${str:i:1}"
		checksum_arr[0]=$(( ( checksum_arr[0] + val ) % 256 ))
		for (( i2 = 1; i2 < checksum_len; i2++ )); do
			checksum_arr[i2]=$(( ( checksum_arr[i2] + checksum_arr[i2-1] ) % 256 ))
		done
	done


	printf -v bashash__out '%02x' "${checksum_arr[@]}"
}



# Validate and define variables
[[ $delim ]] || print_stderr 1 '%s\n' 'no command delimiter provided'
[[ ${#cmd_segs[@]} != '0' ]] || print_stderr 1 '%s\n' 'no command(s) provided'

temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'



# Derive the fifo path from a checksum of the instance name or the exec portion of the parameters
[[ $name ]] && bashash_main "$name" || bashash_main "${cmd_segs[*]}"
fifo_path="${temp_dir}/${0##*/}__${USER}_${bashash__out}"




# If an instance is already running, perform an activation and exit
if [[ -p $fifo_path ]]; then
	printf '\n' > "$fifo_path"
	exit
fi



# Create a non-blocking fifo that's removed on EXIT
[[ -e $fifo_path ]] && rm -- "$fifo_path"

on_exit() {
	[[ -e $fifo_path ]] && rm -- "$fifo_path"
}
trap 'on_exit' 'EXIT'

mkfifo --mode 0600 -- "$fifo_path"
exec 5<>"$fifo_path" 3>"$fifo_path" 4<"$fifo_path" 5>&-



# Define index and number of parameters of each command
cmd_num_to_pos=()
cmd_num_to_params=()
cmds_last_index=0
i=0
for param in "${cmd_segs[@]}"; do
	if [[ $param == "$delim" ]]; then
		(( cmds_last_index++ )) || :
		(( i++ )) || :
		continue
	fi

	if [[ ${cmd_num_to_pos[$cmds_last_index]} ]]; then
		(( cmd_num_to_params[cmds_last_index]++ ))
	else
		# New command
		cmd_num_to_pos[cmds_last_index]=$i
		cmd_num_to_params[cmds_last_index]=1
	fi
	(( i++ )) || :
done



# Define command to run according to script activations within the rolling delay
# Skip reading for script activations if there's only one command and overun is prevented
cmd_num=0
if (( cmds_last_index > 0 )) || [[ ! $prevent_overrun ]]; then
	while read -t "$activation_timeout" -u 4; do
		(( cmd_num++ )) || :
		[[ $prevent_overrun ]] && (( cmd_num == cmds_last_index )) && break
	done
	(( cmd_num <= cmds_last_index )) || exit 0
fi
[[ ${cmd_num_to_pos[$cmd_num]} ]] || exit 0
cmd_to_run=(${cmd_segs[@]:${cmd_num_to_pos[$cmd_num]}:${cmd_num_to_params[$cmd_num]}})



if [[ $dry_run ]]; then
	eval() {
		printf '%q ' 'eval' "$@"; printf '\n'
	} 1>&2
fi



eval -- "${cmd_to_run[@]}" & disown



