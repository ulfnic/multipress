#!/usr/bin/env bash
[[ $DEBUG ]] && set -x
set -o errexit


help_doc() {
	{ read -r -d '' || :; [[ $REPLY == '|'* ]] && REPLY=${REPLY:1}; printf '%s' "${REPLY//$'\n|'/$'\n'}"; } <<-'HelpDoc'
		|multipress [ARGUEMENT...] [--] [COMMAND|DELIM...]
		|
		|Run one of several COMMANDs based on frequency of execution within a rolling timeout.
		|
		|Useful for a variety of purposes such as extending keyboard shortcut support to include
		|multi-tap combos.

		|DEPENDENCIES
		|	mkfifo

		|ARGUEMENT
		|	-n|--name NAME             Custom name to use for the NAME of the instance
		|	-d|--delim DELIM           Custom delimiter to seperate COMMANDs, default: '__'
		|	-t|--timeout SECONDS       Custom timeout for waiting for next ACTIVATION, default: 0.3
		|	-p|--prevent-overrun       Run the last COMMAND if reached by ACTIVATIONs
		|	-c|--command-string-mode   See: Command String mode
		|	--dry-run                  Do everything except run the COMMAND, print it instead
		|	-h|--help                  Print help doc
		|	--                         End option processing
		|	COMMAND || DELIM

		|ENVIRONMENT
		|	TMPDIR || XDG_RUNTIME_DIR   Directory to use for fifo file, fallback: /tmp
		|	DEBUG                       Use set -x to print debugging information

		|NAME
		|	Part of the filename used for the IPC fifo file. All parameters containing COMMAND
		|	and DELIM are hashed to produce the NAME. If a custom name is given that value is
		|	hashed instead. In both cases Command String mode state is included in the hash.

		|COMMAND || DELIM
		|	A COMMAND is executed according to its order based on the number of ACTIVATIONs.
		|	For example, two timely ACTIVATIONs of the script will run the second COMMAND.
		|
		|	Normal mode:
		|		A series of single command(s) including their parameters divided by DELIM
		|		which are run without shell interpretation/expansion.
		|
		|	Command String mode:
		|		Does not recognize DELIM. A series of command string(s) evaluated with bash -c
		
		|ACTIVATION
		|	Each execution of the script constitutions an ACTIVATION under a given NAME.
		|
		|	If no script is listening under a NAME, the script listens for ACTIVATIONs until
		|	the timeout is reached from last ACTIVATION.
		|
		|	If a script is already listening under NAME, the script writes an ACTIVATION to
		|	that instance over IPC (see: NAME).

		|EXAMPLES
		|	# Attach these to a keybind in your keyboard manager and try single and double tap.
		|
		|	# Normal mode
		|	multipress -- notify-send 'activated once' __ notify-send 'activated twice'
		|
		|	# Command String mode
		|	multipress -c -- "notify-send 'activated once'" "notify-send 'activated twice'"
	HelpDoc
	[[ $1 ]] && exit "$1"
}



print_stderr() {
	if [[ $1 == '0' ]]; then
		[[ $2 ]] && printf "$2" "${@:3}" 1>&2 || :
	else
		[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
		exit "$1"
	fi
}



name=
delim='__'
activation_timeout='0.3'
prevent_overrun=
is_command_string_mode=
dry_run=
cmd_segs=()
while [[ "$1" ]]; do
	case $1 in
		'--name'|'-n')
			shift; name=$1 ;;
		'--delim'|'-d')
			shift; delim=$1 ;;
		'--timeout'|'-t')
			shift; activation_timeout=$1 ;;
		'--prevent-overrun'|'-p')
			prevent_overrun=1 ;;
		'--command-string-mode'|'-c')
			is_command_string_mode=1 ;;
		'--dry-run')
			dry_run=1 ;;
		'--help'|'-h')
			help_doc 0 ;;
		'--')
			shift; break ;;
		'-'*)
			print_stderr 1 '%s\n' 'unrecognized option: '"$1" ;;
		*)
			cmd_segs+=("$1")
	esac
	shift
done
cmd_segs+=("$@")



# Validate arguements
[[ $delim ]] || print_stderr 1 '%s\n' 'no command delimiter provided'
[[ ${#cmd_segs[@]} != '0' ]] || print_stderr 1 '%s\n' 'no command(s) provided'



# Define temp directory for fifo file
temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'



# Define function for generating fast checksums
bashash_main() {
	bashash__out=
	local \
		str=$1 \
		checksum_len=${2:-16} \
		checksum_arr=(1)
	local str_len=${#str}


	for (( i = 0; i < str_len; i++ )); do
		printf -v val '%d' "'${str:i:1}"
		checksum_arr[0]=$(( ( checksum_arr[0] + val ) % 256 ))
		for (( i2 = 1; i2 < checksum_len; i2++ )); do
			checksum_arr[i2]=$(( ( checksum_arr[i2] + checksum_arr[i2-1] ) % 256 ))
		done
	done


	printf -v bashash__out '%02x' "${checksum_arr[@]}"
}



# Validate and define variables
[[ $delim ]] || print_stderr 1 '%s\n' 'no command delimiter provided'
[[ ${#cmd_segs[@]} != '0' ]] || print_stderr 1 '%s\n' 'no command(s) provided'

temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'



# Derive the fifo path from a checksum of the instance name or the exec portion of the parameters
if [[ $name ]]; then
	bashash_main "${is_command_string_mode}${name}"
else
	bashash_main "${is_command_string_mode}${cmd_segs[*]}"
fi
fifo_path="${temp_dir}/${0##*/}__${USER}_${bashash__out}"



# If an instance is already running, perform an activation and exit
if [[ -p $fifo_path ]]; then
	printf '\n' > "$fifo_path"
	exit
fi



# Create a non-blocking fifo that's removed on EXIT
[[ -e $fifo_path ]] && rm -- "$fifo_path"

on_exit() {
	[[ -e $fifo_path ]] && rm -- "$fifo_path"
}
trap 'on_exit' 'EXIT'

mkfifo --mode 0600 -- "$fifo_path"
exec 5<>"$fifo_path" 3>"$fifo_path" 4<"$fifo_path" 5>&-



if [[ $is_command_string_mode ]]; then
	cmds_last_index=$(( ${#cmd_segs[@]} - 1 ))

else
	# Define index and number of parameters of each command
	cmd_num_to_pos=()
	cmd_num_to_params=()
	cmds_last_index=0
	i=0
	for param in "${cmd_segs[@]}"; do
		if [[ $param == "$delim" ]]; then
			(( cmds_last_index++ )) || :
			(( i++ )) || :
			continue
		fi

		if [[ ${cmd_num_to_pos[$cmds_last_index]} ]]; then
			(( cmd_num_to_params[cmds_last_index]++ ))
		else
			# New command
			cmd_num_to_pos[cmds_last_index]=$i
			cmd_num_to_params[cmds_last_index]=1
		fi
		(( i++ )) || :
	done
fi



# Define command to run according to script activations within the rolling delay
# Skip reading for script activations if there's only one command and overun is prevented
cmd_num=0
if (( cmds_last_index > 0 )) || [[ ! $prevent_overrun ]]; then
	while read -t "$activation_timeout" -u 4; do
		(( cmd_num++ )) || :
		[[ $prevent_overrun ]] && (( cmd_num == cmds_last_index )) && break
	done
	(( cmd_num <= cmds_last_index )) || exit 0
fi



if [[ $is_command_string_mode ]]; then
	[[ ${cmd_segs[$cmd_num]} ]] || exit 0
	cmd_to_run=${cmd_segs[$cmd_num]}

else
	[[ ${cmd_num_to_pos[$cmd_num]} ]] || exit 0
	MULTIPRESS__SELECTED_CMD=("${cmd_segs[@]:${cmd_num_to_pos[$cmd_num]}:${cmd_num_to_params[$cmd_num]}}")
	cmd_to_run=
	cmd_to_run+=$(declare -p MULTIPRESS__SELECTED_CMD)';'
	cmd_to_run+='"${MULTIPRESS__SELECTED_CMD[@]}";'
fi



[[ $dry_run ]] && bash() { printf '%q ' 'bash' "$@"; printf '\n'; } 1>&2
bash -c "$cmd_to_run" & disown
[[ $dry_run ]] && unset -f bash



