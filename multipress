#!/usr/bin/env bash
[[ $DEBUG ]] && set -x
set -o errexit


help_doc() {
	{ read -r -d '' || :; [[ $REPLY == '|'* ]] && REPLY=${REPLY:1}; printf '%s' "${REPLY//$'\n|'/$'\n'}"; } <<-'HelpDoc'
		|multipress [ARGUEMENT...] [--] [COMMAND|DELIM...]
		|
		|Run one of several COMMANDs based on frequency of execution within a rolling timeout.
		|
		|Useful for a variety of purposes such as extending keyboard shortcut support to include
		|multi-tap combos.

		|DEPENDENCIES
		|	mkfifo

		|ARGUEMENT
		|	-n|--name NAME             Custom name to use for the NAME of the instance
		|	-d|--delim DELIM           Custom delimiter to seperate COMMANDs, default: '__'
		|	-t|--timeout SECONDS       Custom timeout for waiting for next ACTIVATION, default: 0.3
		|	-p|--prevent-overrun       Run the last COMMAND if reached by ACTIVATIONs
		|	-c|--command-string-mode   See: Command String mode
		|	--dry-run                  Do everything except running the COMMAND, print it instead
		|	-h|--help                  Print help doc
		|	--                         End option processing
		|	COMMAND || DELIM

		|ENVIRONMENT
		|	TMPDIR || XDG_RUNTIME_DIR   Directory to use for fifo file, fallback: /tmp
		|	DEBUG                       Use set -x to print debugging information

		|NAME
		|	Part of the filename used for the IPC fifo file. All parameters containing COMMAND
		|	and DELIM are hashed to produce the NAME. If a custom name is given that value is
		|	hashed instead. In both cases Command String mode state is included in the hash.

		|COMMAND || DELIM
		|	A COMMAND is executed according to its order based on the number of ACTIVATIONs.
		|	For example, two timely ACTIVATIONs of the script will run the second COMMAND.
		|
		|	Normal mode:
		|		A series of command(s) with parameters divided by DELIM that undergo shell
		|		interpretation and are evaluated with eval.
		|
		|	Command String mode:
		|		Does not recognize DELIM. A series of command string(s) evaluated with bash -c
		
		|ACTIVATION
		|	Each execution of the script constitutions an ACTIVATION under a given NAME.
		|
		|	If no script is listening under a NAME, the script listens for ACTIVATIONs until
		|	the timeout is reached from last ACTIVATION.
		|
		|	If a script is already listening under NAME, the script writes an ACTIVATION to
		|	that instance over IPC (see: NAME).

		|EXAMPLES
		|	# Attach these to a keybind in your keyboard manager and try single and double tap.
		|
		|	# Normal mode
		|	multipress -- notify-send 'activated once' __ notify-send 'activated twice'
		|
		|	# Command String mode
		|	multipress -c -- "notify-send 'activated once'" "notify-send 'activated twice'"
	HelpDoc
	[[ $1 ]] && exit "$1"
}



print_stderr() {
	if [[ $1 == '0' ]]; then
		[[ $2 ]] && printf "$2" "${@:3}" 1>&2 || :
	else
		[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
		exit "$1"
	fi
}



# Define function for generating fast checksums
bashash_main() {
	bashash__out=
	local \
		str=$1 \
		checksum_len=${2:-16} \
		checksum_arr=(1)
	local str_len=${#str}


	for (( i = 0; i < str_len; i++ )); do
		printf -v val '%d' "'${str:i:1}"
		checksum_arr[0]=$(( ( checksum_arr[0] + val ) % 256 ))
		for (( i2 = 1; i2 < checksum_len; i2++ )); do
			checksum_arr[i2]=$(( ( checksum_arr[i2] + checksum_arr[i2-1] ) % 256 ))
		done
	done


	printf -v bashash__out '%02x' "${checksum_arr[@]}"
}



parse_arguments() {
	while [[ "$1" ]]; do
		case $1 in
			'--name'|'-n')
				shift; name=$1 ;;
			'--delim'|'-d')
				shift; delim=$1 ;;
			'--timeout'|'-t')
				shift; activation_timeout=$1 ;;
			'--prevent-overrun'|'-p')
				prevent_overrun=1 ;;
			'--command-string-mode'|'-c')
				command_string_mode=1 ;;
			'--dry-run')
				dry_run=1 ;;
			'--help'|'-h')
				help_doc 0 ;;
			'--')
				shift; break ;;
			'-'*)
				print_stderr 1 '%s\n' 'unrecognized option: '"$1" ;;
			*)
				cmd_segs+=("$1")
		esac
		shift
	done
	cmd_segs+=("$@")
}


validate_inputs() {
	[[ $delim ]] || print_stderr 1 '%s\n' 'no command delimiter provided'
	[[ ${#cmd_segs[@]} != '0' ]] || print_stderr 1 '%s\n' 'no command(s) provided'
	temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
	[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'
}


setup_fifo() {
	# Derive the fifo path from a checksum of the instance name or the exec portion of the parameters
	if [[ $name ]]; then
		bashash_main "${command_string_mode}${name}"
	else
		bashash_main "${command_string_mode}${cmd_segs[*]}"
	fi
	fifo_path="${temp_dir}/${0##*/}__${USER}_${bashash__out}"

	# If an instance is already running, perform an activation and exit
	if [[ -p $fifo_path ]]; then
		printf '\n' > "$fifo_path"
		exit
	fi

	# Create a non-blocking fifo that's removed on EXIT
	[[ -e $fifo_path ]] && rm -- "$fifo_path"

	on_exit() {
		[[ -e $fifo_path ]] && rm -- "$fifo_path"
	}
	trap 'on_exit' 'EXIT'

	mkfifo --mode 0600 -- "$fifo_path"
	exec 5<>"$fifo_path" 3>"$fifo_path" 4<"$fifo_path" 5>&-
}


parse_commands() {
	if [[ $command_string_mode ]]; then
		cmds_last_index=$(( ${#cmd_segs[@]} - 1 ))
	else
		# Define index and number of parameters of each command
		cmd_num_to_pos=()
		cmd_num_to_params=()
		cmds_last_index=0
		i=0
		for param in "${cmd_segs[@]}"; do
			if [[ $param == "$delim" ]]; then
				(( cmds_last_index++ )) || :
				(( i++ )) || :
				continue
			fi

			if [[ ${cmd_num_to_pos[$cmds_last_index]} ]]; then
				(( cmd_num_to_params[cmds_last_index]++ ))
			else
				# New command
				cmd_num_to_pos[cmds_last_index]=$i
				cmd_num_to_params[cmds_last_index]=1
			fi
			(( i++ )) || :
		done
	fi
}


wait_for_activations() {
	# Define command to run according to script activations within the rolling delay
	# Skip reading for script activations if there's only one command and overun is prevented
	cmd_num=0
	if (( cmds_last_index > 0 )) || [[ ! $prevent_overrun ]]; then
		while read -t "$activation_timeout" -u 4; do
			(( cmd_num++ )) || :
			[[ $prevent_overrun ]] && (( cmd_num == cmds_last_index )) && break
		done
		(( cmd_num <= cmds_last_index )) || exit 0
	fi
}


execute_command() {
	if [[ $command_string_mode ]]; then
		[[ ${cmd_segs[$cmd_num]} ]] || exit 0
		[[ $dry_run ]] && bash() { printf '%q ' 'bash' "$@"; printf '\n'; } 1>&2
		bash -c "${cmd_segs[$cmd_num]}" & disown
		exit
	fi

	[[ ${cmd_num_to_pos[$cmd_num]} ]] || exit 0
	cmd_to_run=(${cmd_segs[@]:${cmd_num_to_pos[$cmd_num]}:${cmd_num_to_params[$cmd_num]}})
	[[ $dry_run ]] && eval() { printf '%q ' 'eval' "$@"; printf '\n'; } 1>&2
	eval -- "${cmd_to_run[@]}" & disown
}


main() {
	# Initialize variables
	name=
	delim='__'
	activation_timeout='0.3'
	prevent_overrun=
	command_string_mode=
	dry_run=
	cmd_segs=()
	
	parse_arguments "$@"
	validate_inputs
	setup_fifo
	parse_commands
	wait_for_activations
	execute_command
}



main "$@"
